\hyperlink{a00019}{JPPipeline} implements an advanced form of the \href{http://java.sun.com/blueprints/corej2eepatterns/Patterns/InterceptingFilter.html}{\tt Intercepting Filter Pattern} to give a user full control over how an event is handled and how the \hyperlink{a00029}{JPPipelineHandler} in the pipeline interact with each other.

\subsection*{How an event flows in a pipeline}

The following diagram describes how a \hyperlink{a00023}{Event} are processed by an \hyperlink{a00029}{Handler} in a \hyperlink{a00019}{Pipeline}. 

A \hyperlink{a00023}{JPPipelineEvent} can be handled by either a \hyperlink{a00035}{JPPipelineUpstreamHandler} or a \hyperlink{a00021}{JPPipelineDownstreamHandler} and be forwarded to the closest handler by calling \hyperlink{a00030_a9ab02ec0933865652634c54595ff7dd7}{sendUpstream: (JPPipelineHandlerContext-\/p)} or \hyperlink{a00030_a292ed51fe0b2e1ce6b2ed517be5fa5e8}{sendDownstream: (JPPipelineHandlerContext-\/p)}. The meaning of the event is interpreted somewhat differently depending on whether it is going upstream or going downstream. Please refer to \hyperlink{a00023}{JPPipelineEvent} for more information.



An upstream event is handled by the upstream handlers in the bottom-\/up direction as shown on the left side of the diagram. An upstream handler usually handles the inbound data on the bottom of the diagram. The inbound data is often read from a remote peer via the actual input operation. If an upstream event goes beyond the top upstream handler, it is discarded silently. 

A downstream event is handled by the downstream handler in the top-\/down direction as shown on the right side of the diagram. A downstream handler usually generates or transforms the outbound traffic such as write requests. If a downstream event goes beyond the bottom downstream handler, it is handled by an transporter object associated with the \hyperlink{a00019}{JPPipeline}. The transporter often performs the actual output operation. 

For example, let us assume that we created the following pipeline: 
\begin{DoxyCode}
 JPPipeline *p = [[JPPipeline init] retain];
 [p addLast:@"1" withHandler:[UpstreamHandlerA init]];
 [p addLast:@"2" withHandler:[UpstreamHandlerB init]];
 [p addLast:@"3" withHandler:[DownstreamHandlerA init]];
 [p addLast:@"4" withHandler:[DownstreamHandlerB init]];
 [p addLast:@"5" withHandler:[UpstreamHandlerX init]];
\end{DoxyCode}


In the example above, the class whose name starts with {\bfseries Upstream} means it is an upstream handler. The class whose name starts with {\bfseries Downstream} means it is a downstream handler. 

In the given example configuration, the handler evaluation order is 1, 2, 3, 4, 5 when an event goes upstream. When an event goes downstream, the order is 5, 4, 3, 2, 1. On top of this principle, \hyperlink{a00019}{JPPipeline} skips the evaluation of certain handlers to shorten the stack depth: 
\begin{DoxyItemize}
\item 3 and 4 don't implement \hyperlink{a00035}{JPPipelineUpstreamHandler}, and therefore the actual evaluation order of an upstream event will be: 1, 2, and 5. 
\item 1, 2, and 5 don't implement \hyperlink{a00021}{JPPipelineDownstreamHandler}, and therefore the actual evaluation order of a downstream event will be: 4 and 3. 
\item If 5 extended \hyperlink{a00038}{JPSimplePipelineHandler} which implements both \hyperlink{a00035}{JPPipelineUpstreamHandler} and \hyperlink{a00021}{JPPipelineDownstreamHandler}, the evaluation order of an upstream and a downstream event could be 1, 2, 5 and 5, 4, 3 respectively. 
\end{DoxyItemize}

\subsection*{Building a pipeline}

A user is supposed to have one or more \hyperlink{a00029}{JPPipelineHandler} in a pipeline to receive I/O events (e.g. read) and to request I/O operations (e.g. write). For example, a typical application will have the following handlers in each channel's pipeline, but your mileage may vary depending on the complexity and characteristics of the protocol and business logic:


\begin{DoxyEnumerate}
\item Protocol Decoder -\/ translates binary data into a Objective-\/C object. 
\item Protocol Encoder -\/ translates a Objective-\/C object into binary data. 
\item Business Logic Handler -\/ performs the actual business logic (e.g. database access). 
\end{DoxyEnumerate}

and it could be represented as shown in the following example:


\begin{DoxyCode}
 JPPipeline* pipeline = [[JPPipeline init] retain];
 [p addLast:@"decoder" withHandler:[MyProtocolDecoder init]];
 [p addLast:@"encoder" withHandler:[MyProtocolEncoder init]];
 [p addLast:@"handler" withHandler:[MyBusinessLogicHandler init]];
\end{DoxyCode}


\subsection*{Thread safety}

A \hyperlink{a00029}{JPPipelineHandler} can be added or removed at any time because a \hyperlink{a00019}{JPPipeline} is thread safe. For example, you can insert a {\bfseries SslHandler} when sensitive information is about to be exchanged, and remove it after the exchange.

\subsection*{Pitfall}

Due to the internal implementation detail of the current default \hyperlink{a00019}{JPPipeline}, the following code does not work as expected if {\ttfamily FirstHandler} is the last handler in the pipeline:


\begin{DoxyCode}
 @interface FirstHandler : JPSimplePipelineUpstreamHandler {}
 @end
 
 @implementation FirstHandler
 
 -(void)messageReceived:(<JPPipelineHandlerContext>)ctx withMessageEvent:(<
      JPPipelineMessageEvent>)e {
         // Remove this handler from the pipeline,
         [[ctx getPipeline] removeByHandler:self];
         // And let SecondHandler handle the current event.
         [[ctx getPipeline] addLast:@"2nd" withHandler:[SecondHandler init]];
         [ctx sendUpstream:e];
 }
 @end
\end{DoxyCode}


To implement the expected behavior, you have to add {\ttfamily SecondHandler} before the removal or make sure there is at least one more handler between {\ttfamily FirstHandler} and {\ttfamily SecondHandler}. 